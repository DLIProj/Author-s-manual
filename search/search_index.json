{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome # Welcome to docs.peachpie.io , the home of the PeachPie documentation for developers. Check out the get started section to jump straight to using PeachPie, or dive into the more advanced topics, such as the .NET reference and API reference . Migrate PHP code to .NET Core The very first step is to get your PHP code running on .NET. Follow the get started and the PHP guide overview topics to create a project and build it as a .NET library. This should give you an overview of using the MSBuild project file , migration tips, the compatibility status and introduce you to working with the project in Visual Studio or Visual Studio Code. .NET interoperability reference In order to benefit from PHP code built as a .NET library, take a look at how to connect a C# project with a PHP project. The section .NET reference provides a documentation on how to pass variables or objects, call methods, share session data, instantiate classes, extend classes etc. between C# and PHP. API reference The project provides a lot of internals that can be used to drive the PHP code life cycle or to implement your own high-performance extensions in .NET. Follow the API reference for more information. Samples, Tutorials, Scenarios See our scenarios for real world use cases, specific code samples and hints on how you can benefit from the project. If you want to understand the objectives and benefits of PeachPie, browse the about section, where you can find the motivation behind this project.","title":"Welcome"},{"location":"#welcome","text":"Welcome to docs.peachpie.io , the home of the PeachPie documentation for developers. Check out the get started section to jump straight to using PeachPie, or dive into the more advanced topics, such as the .NET reference and API reference . Migrate PHP code to .NET Core The very first step is to get your PHP code running on .NET. Follow the get started and the PHP guide overview topics to create a project and build it as a .NET library. This should give you an overview of using the MSBuild project file , migration tips, the compatibility status and introduce you to working with the project in Visual Studio or Visual Studio Code. .NET interoperability reference In order to benefit from PHP code built as a .NET library, take a look at how to connect a C# project with a PHP project. The section .NET reference provides a documentation on how to pass variables or objects, call methods, share session data, instantiate classes, extend classes etc. between C# and PHP. API reference The project provides a lot of internals that can be used to drive the PHP code life cycle or to implement your own high-performance extensions in .NET. Follow the API reference for more information. Samples, Tutorials, Scenarios See our scenarios for real world use cases, specific code samples and hints on how you can benefit from the project. If you want to understand the objectives and benefits of PeachPie, browse the about section, where you can find the motivation behind this project.","title":"Welcome"},{"location":"get-started/","text":"Get started # The purpose of this page is to get you started with PeachPie quickly. The following steps let you to create a minimalistic project containing PHP files and then compile and run them on top of .NET Core. Prerequisites # .NET Core SDK 3.0 or newer: microsoft.com/net/download Install dotnet templates # Open a command prompt and run the following command: install dotnet templates dotnet new -i \"Peachpie.Templates::*\" The dotnet command downloads the latest project template to be used to create new PeachPie projects for you. Create your app # The following steps create a new project in the current directory. They come with a simple hello world code. Console Application # The easiest way to start is to create a console application with PHP code. Open the command prompt and run the following commands: create and run console project dotnet new console -lang PHP dotnet run The first run takes a few seconds, since it will download all the dependencies for the first time and compile the project. Web Application # The second option is to create an ASP.NET Core application that runs a website with compiled PHP. Open the command prompt in a new directory and run the following commands: create and run web project dotnet new web -lang PHP dotnet run -p Server The dotnet new command creates a new project and downloads all the necessary dependencies. The application then compiles and runs a built-in web server on http://localhost:5004 . You can access the page in the browser and see the result of index.php . The newly created web application actually consists of two projects - Server and Website . The first one is a C# .NET Core app that initializes the web server and passes requests to scripts in the second project. You can integrate this solution with a regular .NET Core MVC application with your additional configuration. Class Library # The third project type is a class library. The following command creates a project that builds a .dll file out of your PHP files to be used as a library that can be referenced by other projects - either C# or other PHP projects. create and build class library project dotnet new classlib -lang PHP dotnet build This kind of project can be used purely as a dependency to other projects. The contained classes and interfaces are exposed as regular .NET types. The included script files and global functions are also accessible, either by the PeachPie API or seamlessly within another PHP project that references this library. Development Environment # Projects can be created and opened by .NET development environments, such as Visual Studio or Visual Studio Code . Visual Studio # Install our PeachPie Visual Studio Extension . Go to File | New | Project , locate the PHP (PeachPie) template group and create a new project. Hit F5 . Visual Studio Code # Install PeachPie for VS Code extension. Open the folder with your PHP project. Start the project by pressing F5 and let VSCode create the initial tasks.json and launch.json files for .NET Core. Edit launch.json to point to the actual build result. The steps above add support for PeachPie diagnostics and breakpoints in PHP code within a PHP project in VS Code. The building and debugging of the application is handled by the .NET runtime and debugger.","title":"Get started"},{"location":"get-started/#get-started","text":"The purpose of this page is to get you started with PeachPie quickly. The following steps let you to create a minimalistic project containing PHP files and then compile and run them on top of .NET Core.","title":"Get started"},{"location":"get-started/#prerequisites","text":".NET Core SDK 3.0 or newer: microsoft.com/net/download","title":"Prerequisites"},{"location":"get-started/#install-dotnet-templates","text":"Open a command prompt and run the following command: install dotnet templates dotnet new -i \"Peachpie.Templates::*\" The dotnet command downloads the latest project template to be used to create new PeachPie projects for you.","title":"Install dotnet templates"},{"location":"get-started/#create-your-app","text":"The following steps create a new project in the current directory. They come with a simple hello world code.","title":"Create your app"},{"location":"get-started/#console-application","text":"The easiest way to start is to create a console application with PHP code. Open the command prompt and run the following commands: create and run console project dotnet new console -lang PHP dotnet run The first run takes a few seconds, since it will download all the dependencies for the first time and compile the project.","title":"Console Application"},{"location":"get-started/#web-application","text":"The second option is to create an ASP.NET Core application that runs a website with compiled PHP. Open the command prompt in a new directory and run the following commands: create and run web project dotnet new web -lang PHP dotnet run -p Server The dotnet new command creates a new project and downloads all the necessary dependencies. The application then compiles and runs a built-in web server on http://localhost:5004 . You can access the page in the browser and see the result of index.php . The newly created web application actually consists of two projects - Server and Website . The first one is a C# .NET Core app that initializes the web server and passes requests to scripts in the second project. You can integrate this solution with a regular .NET Core MVC application with your additional configuration.","title":"Web Application"},{"location":"get-started/#class-library","text":"The third project type is a class library. The following command creates a project that builds a .dll file out of your PHP files to be used as a library that can be referenced by other projects - either C# or other PHP projects. create and build class library project dotnet new classlib -lang PHP dotnet build This kind of project can be used purely as a dependency to other projects. The contained classes and interfaces are exposed as regular .NET types. The included script files and global functions are also accessible, either by the PeachPie API or seamlessly within another PHP project that references this library.","title":"Class Library"},{"location":"get-started/#development-environment","text":"Projects can be created and opened by .NET development environments, such as Visual Studio or Visual Studio Code .","title":"Development Environment"},{"location":"get-started/#visual-studio","text":"Install our PeachPie Visual Studio Extension . Go to File | New | Project , locate the PHP (PeachPie) template group and create a new project. Hit F5 .","title":"Visual Studio"},{"location":"get-started/#visual-studio-code","text":"Install PeachPie for VS Code extension. Open the folder with your PHP project. Start the project by pressing F5 and let VSCode create the initial tasks.json and launch.json files for .NET Core. Edit launch.json to point to the actual build result. The steps above add support for PeachPie diagnostics and breakpoints in PHP code within a PHP project in VS Code. The building and debugging of the application is handled by the .NET runtime and debugger.","title":"Visual Studio Code"},{"location":"antora/","text":"Install # Include https://gitlab.com/antora/antora/-/issues/596 Antora process # Convert docx to html pandoc -f docx -t html -s -o PMM.html PMM.docx Clean html Convert html to md pandoc -s -r html pmm.html -o pmm.md Convert md to ascii Webpage to docx pandoc --reference-doc pandocTheme.docx -f html -t docx -o HugiOmg.docx http://127.0.0.1:5000/ess/performance-management/index.html#_plan_assignment wkhtmltopdf http://127.0.0.1:4000/docs/CSharpCodingStandards.html google.pdf Conversion # pip3 uninstall mkpdfs-mkdocs Serve # Install npm i -g http-server yarn global add http-server npm i -g @asciidoctor/core asciidoctor-pdf npm run clean-install and then npm run build gem install asciidoctor Misc # npm i -g @asciidoctor/core asciidoctor-pdf npm run clean-install and then npm run build","title":"Install"},{"location":"antora/#install","text":"Include https://gitlab.com/antora/antora/-/issues/596","title":"Install"},{"location":"antora/#antora-process","text":"Convert docx to html pandoc -f docx -t html -s -o PMM.html PMM.docx Clean html Convert html to md pandoc -s -r html pmm.html -o pmm.md Convert md to ascii Webpage to docx pandoc --reference-doc pandocTheme.docx -f html -t docx -o HugiOmg.docx http://127.0.0.1:5000/ess/performance-management/index.html#_plan_assignment wkhtmltopdf http://127.0.0.1:4000/docs/CSharpCodingStandards.html google.pdf","title":"Antora process"},{"location":"antora/#conversion","text":"pip3 uninstall mkpdfs-mkdocs","title":"Conversion"},{"location":"antora/#serve","text":"Install npm i -g http-server yarn global add http-server npm i -g @asciidoctor/core asciidoctor-pdf npm run clean-install and then npm run build gem install asciidoctor","title":"Serve"},{"location":"antora/#misc","text":"npm i -g @asciidoctor/core asciidoctor-pdf npm run clean-install and then npm run build","title":"Misc"},{"location":"antora/authoring/","text":"Authoring # Antora authring guidelines Antora process # Do conversion (HTML/DocX/Markdown) Clean html Convert html to md Convert md to ascii Antora commands # Antora fetch # antora antora - playbook . yml antora -- fetch antora - playbook . yml antora -- fetch author - mode . yml Antora fetch local lunr # aantora-playbook.yml # set \"DOCSEARCH_ENABLED=true\" && set \"DOCSEARCH_ENGINE=lunr\" && antora -- generator antora - site - generator - lunr antora - playbook . yml author-mode.yml # set \"DOCSEARCH_ENABLED=true\" && set \"DOCSEARCH_ENGINE=lunr\" && antora -- generator antora - site - generator - lunr author - mode . yml local-playbook.yml # set \"DOCSEARCH_ENABLED=true\" && set \"DOCSEARCH_ENGINE=lunr\" && antora -- generator antora - site - generator - lunr local - playbook . yml Install local serve # Install server 1 2 3 4 5 npm i - g http - server OR yarn global add http - server Serve # 1 2 3 http - server build / site - c - 1 http - server build / site - c - 1 - p 5000 - c - 1 flag to disable caching http - server build / site - c - 1 - p 5000 DDOCSEARCH_ENABLED = true DOCSEARCH_ENGINE = lunr antora site . yml Formatting # [ % autowidth ] |=== | A | B | C |=== Include # https://gitlab.com/antora/antora/-/issues/596 Mindfulness # https://www.youtube.com/watch?v=7-bPYMAdnnM https://www.youtube.com/watch?v=h-CYAQqpvcw Doctype book level 0 error # = Book Title : chapter : 12 : sectnums : : sectnumoffset : 11 ( chapter minus 1 ) : leveloffset : 1","title":"Authoring"},{"location":"antora/authoring/#authoring","text":"Antora authring guidelines","title":"Authoring"},{"location":"antora/authoring/#antora-process","text":"Do conversion (HTML/DocX/Markdown) Clean html Convert html to md Convert md to ascii","title":"Antora process"},{"location":"antora/authoring/#antora-commands","text":"","title":"Antora commands"},{"location":"antora/authoring/#antora-fetch","text":"antora antora - playbook . yml antora -- fetch antora - playbook . yml antora -- fetch author - mode . yml","title":"Antora fetch"},{"location":"antora/authoring/#antora-fetch-local-lunr","text":"","title":"Antora fetch local lunr"},{"location":"antora/authoring/#aantora-playbookyml","text":"set \"DOCSEARCH_ENABLED=true\" && set \"DOCSEARCH_ENGINE=lunr\" && antora -- generator antora - site - generator - lunr antora - playbook . yml","title":"aantora-playbook.yml"},{"location":"antora/authoring/#author-modeyml","text":"set \"DOCSEARCH_ENABLED=true\" && set \"DOCSEARCH_ENGINE=lunr\" && antora -- generator antora - site - generator - lunr author - mode . yml","title":"author-mode.yml"},{"location":"antora/authoring/#local-playbookyml","text":"set \"DOCSEARCH_ENABLED=true\" && set \"DOCSEARCH_ENGINE=lunr\" && antora -- generator antora - site - generator - lunr local - playbook . yml","title":"local-playbook.yml"},{"location":"antora/authoring/#install-local-serve","text":"Install server 1 2 3 4 5 npm i - g http - server OR yarn global add http - server","title":"Install local serve"},{"location":"antora/authoring/#serve","text":"1 2 3 http - server build / site - c - 1 http - server build / site - c - 1 - p 5000 - c - 1 flag to disable caching http - server build / site - c - 1 - p 5000 DDOCSEARCH_ENABLED = true DOCSEARCH_ENGINE = lunr antora site . yml","title":"Serve"},{"location":"antora/authoring/#formatting","text":"[ % autowidth ] |=== | A | B | C |===","title":"Formatting"},{"location":"antora/authoring/#include","text":"https://gitlab.com/antora/antora/-/issues/596","title":"Include"},{"location":"antora/authoring/#mindfulness","text":"https://www.youtube.com/watch?v=7-bPYMAdnnM https://www.youtube.com/watch?v=h-CYAQqpvcw","title":"Mindfulness"},{"location":"antora/authoring/#doctype-book-level-0-error","text":"= Book Title : chapter : 12 : sectnums : : sectnumoffset : 11 ( chapter minus 1 ) : leveloffset : 1","title":"Doctype book level 0 error"},{"location":"antora/conversion/","text":"Conversion # Docx to Markdown # Docx to Markdown with images pandoc - o SalaryRegister . md -- extract - media =./ SalaryRegister . docx HTML to Docx # pandoc -- reference - doc pandocTheme . docx - f html - t docx - o DailyTS . docx https : // site / wagetype - based - timesheet / HTML to Markdown # pandoc -s -r html pmm.html -o pmm.md HTML to ASCIIDOC # pandoc - f html - t asciidoctor - o PRL_PayrollSheet00 . adoc PRL_PayrollSheet00 . html wkhtmltopdf # wkhtmltopdf http : // 127.0.0.1 : 4000 / docs / CSharpCodingStandards . html google . pdf Weasyprint # python - m weasyprint http : // weasyprint . org weasyprint . pdf","title":"Conversion"},{"location":"antora/conversion/#conversion","text":"","title":"Conversion"},{"location":"antora/conversion/#docx-to-markdown","text":"Docx to Markdown with images pandoc - o SalaryRegister . md -- extract - media =./ SalaryRegister . docx","title":"Docx to Markdown"},{"location":"antora/conversion/#html-to-docx","text":"pandoc -- reference - doc pandocTheme . docx - f html - t docx - o DailyTS . docx https : // site / wagetype - based - timesheet /","title":"HTML to Docx"},{"location":"antora/conversion/#html-to-markdown","text":"pandoc -s -r html pmm.html -o pmm.md","title":"HTML to Markdown"},{"location":"antora/conversion/#html-to-asciidoc","text":"pandoc - f html - t asciidoctor - o PRL_PayrollSheet00 . adoc PRL_PayrollSheet00 . html","title":"HTML to ASCIIDOC"},{"location":"antora/conversion/#wkhtmltopdf","text":"wkhtmltopdf http : // 127.0.0.1 : 4000 / docs / CSharpCodingStandards . html google . pdf","title":"wkhtmltopdf"},{"location":"antora/conversion/#weasyprint","text":"python - m weasyprint http : // weasyprint . org weasyprint . pdf","title":"Weasyprint"},{"location":"scenarios/","text":"Scenarios overview # Warning The section is not complete yet. This section lists common use cases, problems and solutions. Beginner Intermediate Advanced","title":"Scenarios overview"},{"location":"scenarios/#scenarios-overview","text":"Warning The section is not complete yet. This section lists common use cases, problems and solutions. Beginner Intermediate Advanced","title":"Scenarios overview"},{"location":"scenarios/advanced/computer-chips-hastlayer/","text":"Programming computer chips in PHP using FPGAs and Hastlayer","title":"Computer chips hastlayer"},{"location":"scenarios/advanced/mobile-app/","text":"Building Mobile Application with Xamarin and PeachPie Sample is a work in progress # https://github.com/jakubmisek/UrhoPHPTest","title":"Mobile app"},{"location":"scenarios/advanced/mobile-app/#sample-is-a-work-in-progress","text":"https://github.com/jakubmisek/UrhoPHPTest","title":"Sample is a work in progress"},{"location":"scenarios/beginner/create-nuget/","text":"Create a NuGet package # NuGet packages provide a standardized way of sharing a library functionality across .NET projects. In general, they contain the compiled code (assembly) and other files you want to deliver as a package. Packages are usually pushed to NuGet feeds (public or private), so that they can be referenced by other projects. The process of creating packages is separated from the compilation itself and is fully managed by the build system. This means that projects containing PHP code can be packaged using a standard way, no different from packing other project types. This article summarizes the usual approaches and options. Packing on the command line # The following command creates a default NuGet package ( .nupkg ) containing just the compiled assembly. Run the command within your project directory. dotnet pack Packing within build # Usually it is necessary to alter the project file with the following properties in order to pack the compiled project after a successful build. Insert the following properties into the project file: <GeneratePackageOnBuild> true </GeneratePackageOnBuild> Pack PHPDoc # Creates XMLDoc from the contained PHPDoc and packs it into the NuGet package: <GenerateDocumentationFile> true </GenerateDocumentationFile> Copy content into the NuGet # Most PHP projects contain a decent amout of content that has to be published together with its compiled functionality. This usualy includes images, scripts and styles. <ItemGroup> <Content Include= \"**/*.jpg;**/*.png\" /> </ItemGroup> Note PHP files are compiled and their content is not copied to the package by default. Some functionalities may require the PHP file to be physically present within the target project. Include those required source files in the same way as you would any other content files. <ItemGroup> <Content Include= \"**/*.php\" /> </ItemGroup> Building the project # Build the project to create the package. Run the following command in your favorite command shell: dotnet build Related links # Using compiled project in C# NuGet pack and restore as MSBuild targets (docs.microsoft.com) Signing NuGet Packages (docs.microsoft.com)","title":"Create a NuGet package"},{"location":"scenarios/beginner/create-nuget/#create-a-nuget-package","text":"NuGet packages provide a standardized way of sharing a library functionality across .NET projects. In general, they contain the compiled code (assembly) and other files you want to deliver as a package. Packages are usually pushed to NuGet feeds (public or private), so that they can be referenced by other projects. The process of creating packages is separated from the compilation itself and is fully managed by the build system. This means that projects containing PHP code can be packaged using a standard way, no different from packing other project types. This article summarizes the usual approaches and options.","title":"Create a NuGet package"},{"location":"scenarios/beginner/create-nuget/#packing-on-the-command-line","text":"The following command creates a default NuGet package ( .nupkg ) containing just the compiled assembly. Run the command within your project directory. dotnet pack","title":"Packing on the command line"},{"location":"scenarios/beginner/create-nuget/#packing-within-build","text":"Usually it is necessary to alter the project file with the following properties in order to pack the compiled project after a successful build. Insert the following properties into the project file: <GeneratePackageOnBuild> true </GeneratePackageOnBuild>","title":"Packing within build"},{"location":"scenarios/beginner/create-nuget/#pack-phpdoc","text":"Creates XMLDoc from the contained PHPDoc and packs it into the NuGet package: <GenerateDocumentationFile> true </GenerateDocumentationFile>","title":"Pack PHPDoc"},{"location":"scenarios/beginner/create-nuget/#copy-content-into-the-nuget","text":"Most PHP projects contain a decent amout of content that has to be published together with its compiled functionality. This usualy includes images, scripts and styles. <ItemGroup> <Content Include= \"**/*.jpg;**/*.png\" /> </ItemGroup> Note PHP files are compiled and their content is not copied to the package by default. Some functionalities may require the PHP file to be physically present within the target project. Include those required source files in the same way as you would any other content files. <ItemGroup> <Content Include= \"**/*.php\" /> </ItemGroup>","title":"Copy content into the NuGet"},{"location":"scenarios/beginner/create-nuget/#building-the-project","text":"Build the project to create the package. Run the following command in your favorite command shell: dotnet build","title":"Building the project"},{"location":"scenarios/beginner/create-nuget/#related-links","text":"Using compiled project in C# NuGet pack and restore as MSBuild targets (docs.microsoft.com) Signing NuGet Packages (docs.microsoft.com)","title":"Related links"},{"location":"scenarios/beginner/full-net-framework/","text":"Target .NET Framework # (not .NET Core) Projects built with PeachPie depend on the PeachPie runtime, which targets .NET Standard 2.0 . This makes it compatible with the vast array of other .NET frameworks and runtimes, as long as they are compatible with .NET Standard 2.0. This includes .NET Core 2.0, Mono 5.4, Xamarin.Android 8.0, or .NET Framework 4.6.1 or higher. Building the project # Build a library # When compiling a library project to be referenced by other projects, it is always the best option to target the lowest .NET Standard makes it possible for the project to be referenced by a majority of .NET projects. In this case, it is netstandard2.0 . Make sure you have the following property set in the project file : <TargetFramework> netstandard2.0 </TargetFramework> Build an executable # In order to build an executable application for the .NET Framework (not .NET Core), target net461 or higher and specify the output type exe in the project file : <OutputType> exe </OutputType> <TargetFramework> net461 </TargetFramework> Optionally, specify the startup object , which should be called upon starting the application. ASP.NET application # Assuming the project with PHP files is compiled as a library, you can be targeting either netstandard2.0 or net461 . <TargetFramework> net461 </TargetFramework> <AssemblyName> MyWebsite </AssemblyName> <!-- an optional name --> Add a package reference to request handler: <ItemGroup> <PackageReference Include= \"Peachpie.RequestHandler\" Version= \"1.0.6\" /> </ItemGroup> You can handle the requests to *.php pages on your ASP.NET (Integrated Pipeline) server (specifically IIS 7, IIS Express or Apache with mod_mono) in two ways; either by modifying web.config and passing requests directly to MyWebsite.dll , or by handling the requests programatically in your C# code. Option 1: Web.Config # Alter the web application's web.config file with the following configuration within <configuration> root element: <system.webServer> <handlers> <add name= \"PeachpieHandler\" path= \"*.php\" verb= \"*\" type= \"Peachpie.RequestHandler.RequestHandler, Peachpie.RequestHandler\" resourceType= \"Unspecified\" preCondition= \"integratedMode\" /> </handlers> </system.webServer> Ensure the /bin folder of your ASP.NET application contains all the necessary assemblies including MyWebsite.dll , Peachpie.RequestHandler.dll and other Peachpie runtime assemblies. Option 2: Programatically # In order to handle requests to compiled *.php pages, make use of the RequestHandler API. Obtain the instance of System.Web.HttpContext and pass it to the RequestHandler.ProcessRequest(HttpContext) method. using Peachpie.RequestHandler ; new RequestHandler (). ProcessRequest ( httpContext ); The code above lazily loads PHP library assemblies (e.g. MyWebsite.dll ) and looks up the compiled script corresponding to a given httpContext . If it is found, it gets included and processed. Related links # Target frameworks (docs.microsoft.com) .NET Standard Versions Interactive Table (immo.landwerth.net)","title":"Target .NET Framework"},{"location":"scenarios/beginner/full-net-framework/#target-net-framework","text":"(not .NET Core) Projects built with PeachPie depend on the PeachPie runtime, which targets .NET Standard 2.0 . This makes it compatible with the vast array of other .NET frameworks and runtimes, as long as they are compatible with .NET Standard 2.0. This includes .NET Core 2.0, Mono 5.4, Xamarin.Android 8.0, or .NET Framework 4.6.1 or higher.","title":"Target .NET Framework"},{"location":"scenarios/beginner/full-net-framework/#building-the-project","text":"","title":"Building the project"},{"location":"scenarios/beginner/full-net-framework/#build-a-library","text":"When compiling a library project to be referenced by other projects, it is always the best option to target the lowest .NET Standard makes it possible for the project to be referenced by a majority of .NET projects. In this case, it is netstandard2.0 . Make sure you have the following property set in the project file : <TargetFramework> netstandard2.0 </TargetFramework>","title":"Build a library"},{"location":"scenarios/beginner/full-net-framework/#build-an-executable","text":"In order to build an executable application for the .NET Framework (not .NET Core), target net461 or higher and specify the output type exe in the project file : <OutputType> exe </OutputType> <TargetFramework> net461 </TargetFramework> Optionally, specify the startup object , which should be called upon starting the application.","title":"Build an executable"},{"location":"scenarios/beginner/full-net-framework/#aspnet-application","text":"Assuming the project with PHP files is compiled as a library, you can be targeting either netstandard2.0 or net461 . <TargetFramework> net461 </TargetFramework> <AssemblyName> MyWebsite </AssemblyName> <!-- an optional name --> Add a package reference to request handler: <ItemGroup> <PackageReference Include= \"Peachpie.RequestHandler\" Version= \"1.0.6\" /> </ItemGroup> You can handle the requests to *.php pages on your ASP.NET (Integrated Pipeline) server (specifically IIS 7, IIS Express or Apache with mod_mono) in two ways; either by modifying web.config and passing requests directly to MyWebsite.dll , or by handling the requests programatically in your C# code.","title":"ASP.NET application"},{"location":"scenarios/beginner/full-net-framework/#option-1-webconfig","text":"Alter the web application's web.config file with the following configuration within <configuration> root element: <system.webServer> <handlers> <add name= \"PeachpieHandler\" path= \"*.php\" verb= \"*\" type= \"Peachpie.RequestHandler.RequestHandler, Peachpie.RequestHandler\" resourceType= \"Unspecified\" preCondition= \"integratedMode\" /> </handlers> </system.webServer> Ensure the /bin folder of your ASP.NET application contains all the necessary assemblies including MyWebsite.dll , Peachpie.RequestHandler.dll and other Peachpie runtime assemblies.","title":"Option 1: Web.Config"},{"location":"scenarios/beginner/full-net-framework/#option-2-programatically","text":"In order to handle requests to compiled *.php pages, make use of the RequestHandler API. Obtain the instance of System.Web.HttpContext and pass it to the RequestHandler.ProcessRequest(HttpContext) method. using Peachpie.RequestHandler ; new RequestHandler (). ProcessRequest ( httpContext ); The code above lazily loads PHP library assemblies (e.g. MyWebsite.dll ) and looks up the compiled script corresponding to a given httpContext . If it is found, it gets included and processed.","title":"Option 2: Programatically"},{"location":"scenarios/beginner/full-net-framework/#related-links","text":"Target frameworks (docs.microsoft.com) .NET Standard Versions Interactive Table (immo.landwerth.net)","title":"Related links"},{"location":"scenarios/beginner/reference-php-project/","text":"Referencing a PHP project # This article demonstrates a PHP code provided as a library available as a dependency to other .NET projects (i.e. C# or another PHP). This allows to provide a library written in PHP code to C# projects, to decouple large PHP code bases, or to provide a NuGet package with a PHP library or a whole website. Prerequisites: # .NET Core SDK 3.0 or newer ( dotnet.microsoft.com ) Optionally, Visual Studio 2017 or newer Content: This tutorial goes roughly through the following steps. Creating a PHP library project Adding dependency from a C# project Adding dependency from a PHP project Create a PHP library project # First create a project file. It is an XML file with extension .msbuildproj , describing the library and the build process. library.msbuildproj : <Project Sdk= \"Peachpie.NET.Sdk/1.0.6\" > <PropertyGroup> <OutputType> library </OutputType> <TargetFramework> netstandard2.1 </TargetFramework> <GeneratePackageOnBuild> true </GeneratePackageOnBuild> <GenerateDocumentationFile> true </GenerateDocumentationFile> </PropertyGroup> <ItemGroup> <Compile Include= \"**/*.php\" /> </ItemGroup> </Project> The project file above is used by .NET Core SDK to build the project. It treats all the *.php files as source files, generates a documentation file from containing PHPDoc comments, creates a NuGet package and a resulting library.dll file. Add some code # Let's add some code, create a PHP file next to the project file. The following code defines class Class1 with a single instance function encode . The function accepts value of any type ( mixed type) and returns always a string . class1.php : <?php namespace Library ; /** This is a sample class. */ class Class1 { /** * Our sample encoding function. * @param string $value String to be encoded. */ function encode ( $value ) : string { return json_encode ( $value ); } } Build the library # The library is created. It provides a public class with a sample function that can be used by other PHP or C# projects. On command line, build the project using dotnet build command: dotnet build Expected command result: Microsoft ( R ) Build Engine version 16 .4.0 for .NET Core Copyright ( C ) Microsoft Corporation. All rights reserved. Restore completed in 26 ,77 ms for library.msbuildproj. PeachPie PHP Compiler library -> \\b in \\D ebug \\n etstandard2.0 \\l ibrary.dll Successfully created package '\\bin\\Debug\\library.1.0.0.nupkg' . Build succeeded. 0 Warning ( s ) 0 Error ( s ) Time Elapsed 00 :00:02.45 In case of an error in the source code, it will be reported during the build. In case the error is fatal, i.e. a code that would always cause runtime error, the build process fails. The build outputs library.dll file with the compiled code, library.xml with the compiled documentation, eventually library.pdb containing information for debugger and library.1.0.0.nupkg containing the whole library packed in a standard NuGet file. Adding dependency in Visual Studio # The library project can be directly opened in Visual Studio. Either open an existing solution and add the project into it ( File -> Add -> Existing Project ), or open the project into a new solution ( Ctrl+Shift+O ). In order to use Class1 in the other project, add dependency. Right click onto Dependencies node within ConsoleApp1 , and choose Add reference . Choose the library project as a dependency and comfirm. Now you can build the solution. Adding dependency manually # The dependency can be added without Visual Studio either. Assuming you have another .NET project e.g. ConsoleApp1 and its project file ConsoleApp1.csproj . In order to add dependency to the library, add following into the project file: <ItemGroup> <ProjectReference Include= \"..\\library\\library.msbuildproj\" /> </ItemGroup> Or; you can do the same on command line. See docs.microsoft.com/dotnet/core/tools/dotnet-add-reference for more details. dotnet add reference ../library/library.msbuildproj C# app using the PHP library # Once the library is referenced, either as a ProjectReference or a PackgeReference , its public classes and methods become available to the C# app's code. static void Main ( string [] args ) { // instantiate PHP class var class1 = new Library . Class1 (); // call PHP method with an argument string encoded = class1 . encode ( \"Hello World!\" ); // output the result Console . WriteLine ( encoded ); } There are certain conversion conventions between PHP values and C# types. Please see type system and PhpValue for more details on how the values are implicitly converted. PHP objects and functions are liable to the instance of Context class. If ommited (like in this example) a default instance is provided implicitly. In case of a multithreaded evironment and web applications, make sure you provide an instance of Context corresponding to your current thread. PHP app using the PHP library # In case the library project is referenced by another PHP project (another library or executable), the library become a seamless part of the project. In order to use the class, the containing script file has to be included first. <?php require_once './class1.php' ; $c = new Library\\Class1 ; echo $c -> encode ( 'Hello World!' ); Library subfolder # In most cases, the library script files have to appear in a subfolder when referenced by an application. For example: WordPress plugins should be placed wihtin wp-content/plugins/<pluginnanme> . Composer packages usually in vendor/<vendorname>/<packagename> . Also custom library should be placed within a unique subfolder to avoid conflicts with other script file paths. To do so, add following property into the project file library.msbuildproj : <PropertyGroup> <PhpRelativePath> vendor/example/library </PhpRelativePath> </PropertyGroup> More at project file's PhpRelativePath . After that, the script file class1.php can be included at <?php require_once './vendor/example/library/class1.php' ; See also # Creating a NuGet from a PHP project What is NuGet (docs.microsoft.com) Signing NuGet Packages (docs.microsoft.com) Project File Reference","title":"Referencing a PHP project"},{"location":"scenarios/beginner/reference-php-project/#referencing-a-php-project","text":"This article demonstrates a PHP code provided as a library available as a dependency to other .NET projects (i.e. C# or another PHP). This allows to provide a library written in PHP code to C# projects, to decouple large PHP code bases, or to provide a NuGet package with a PHP library or a whole website.","title":"Referencing a PHP project"},{"location":"scenarios/beginner/reference-php-project/#prerequisites","text":".NET Core SDK 3.0 or newer ( dotnet.microsoft.com ) Optionally, Visual Studio 2017 or newer Content: This tutorial goes roughly through the following steps. Creating a PHP library project Adding dependency from a C# project Adding dependency from a PHP project","title":"Prerequisites:"},{"location":"scenarios/beginner/reference-php-project/#create-a-php-library-project","text":"First create a project file. It is an XML file with extension .msbuildproj , describing the library and the build process. library.msbuildproj : <Project Sdk= \"Peachpie.NET.Sdk/1.0.6\" > <PropertyGroup> <OutputType> library </OutputType> <TargetFramework> netstandard2.1 </TargetFramework> <GeneratePackageOnBuild> true </GeneratePackageOnBuild> <GenerateDocumentationFile> true </GenerateDocumentationFile> </PropertyGroup> <ItemGroup> <Compile Include= \"**/*.php\" /> </ItemGroup> </Project> The project file above is used by .NET Core SDK to build the project. It treats all the *.php files as source files, generates a documentation file from containing PHPDoc comments, creates a NuGet package and a resulting library.dll file.","title":"Create a PHP library project"},{"location":"scenarios/beginner/reference-php-project/#add-some-code","text":"Let's add some code, create a PHP file next to the project file. The following code defines class Class1 with a single instance function encode . The function accepts value of any type ( mixed type) and returns always a string . class1.php : <?php namespace Library ; /** This is a sample class. */ class Class1 { /** * Our sample encoding function. * @param string $value String to be encoded. */ function encode ( $value ) : string { return json_encode ( $value ); } }","title":"Add some code"},{"location":"scenarios/beginner/reference-php-project/#build-the-library","text":"The library is created. It provides a public class with a sample function that can be used by other PHP or C# projects. On command line, build the project using dotnet build command: dotnet build Expected command result: Microsoft ( R ) Build Engine version 16 .4.0 for .NET Core Copyright ( C ) Microsoft Corporation. All rights reserved. Restore completed in 26 ,77 ms for library.msbuildproj. PeachPie PHP Compiler library -> \\b in \\D ebug \\n etstandard2.0 \\l ibrary.dll Successfully created package '\\bin\\Debug\\library.1.0.0.nupkg' . Build succeeded. 0 Warning ( s ) 0 Error ( s ) Time Elapsed 00 :00:02.45 In case of an error in the source code, it will be reported during the build. In case the error is fatal, i.e. a code that would always cause runtime error, the build process fails. The build outputs library.dll file with the compiled code, library.xml with the compiled documentation, eventually library.pdb containing information for debugger and library.1.0.0.nupkg containing the whole library packed in a standard NuGet file.","title":"Build the library"},{"location":"scenarios/beginner/reference-php-project/#adding-dependency-in-visual-studio","text":"The library project can be directly opened in Visual Studio. Either open an existing solution and add the project into it ( File -> Add -> Existing Project ), or open the project into a new solution ( Ctrl+Shift+O ). In order to use Class1 in the other project, add dependency. Right click onto Dependencies node within ConsoleApp1 , and choose Add reference . Choose the library project as a dependency and comfirm. Now you can build the solution.","title":"Adding dependency in Visual Studio"},{"location":"scenarios/beginner/reference-php-project/#adding-dependency-manually","text":"The dependency can be added without Visual Studio either. Assuming you have another .NET project e.g. ConsoleApp1 and its project file ConsoleApp1.csproj . In order to add dependency to the library, add following into the project file: <ItemGroup> <ProjectReference Include= \"..\\library\\library.msbuildproj\" /> </ItemGroup> Or; you can do the same on command line. See docs.microsoft.com/dotnet/core/tools/dotnet-add-reference for more details. dotnet add reference ../library/library.msbuildproj","title":"Adding dependency manually"},{"location":"scenarios/beginner/reference-php-project/#c-app-using-the-php-library","text":"Once the library is referenced, either as a ProjectReference or a PackgeReference , its public classes and methods become available to the C# app's code. static void Main ( string [] args ) { // instantiate PHP class var class1 = new Library . Class1 (); // call PHP method with an argument string encoded = class1 . encode ( \"Hello World!\" ); // output the result Console . WriteLine ( encoded ); } There are certain conversion conventions between PHP values and C# types. Please see type system and PhpValue for more details on how the values are implicitly converted. PHP objects and functions are liable to the instance of Context class. If ommited (like in this example) a default instance is provided implicitly. In case of a multithreaded evironment and web applications, make sure you provide an instance of Context corresponding to your current thread.","title":"C# app using the PHP library"},{"location":"scenarios/beginner/reference-php-project/#php-app-using-the-php-library","text":"In case the library project is referenced by another PHP project (another library or executable), the library become a seamless part of the project. In order to use the class, the containing script file has to be included first. <?php require_once './class1.php' ; $c = new Library\\Class1 ; echo $c -> encode ( 'Hello World!' );","title":"PHP app using the PHP library"},{"location":"scenarios/beginner/reference-php-project/#library-subfolder","text":"In most cases, the library script files have to appear in a subfolder when referenced by an application. For example: WordPress plugins should be placed wihtin wp-content/plugins/<pluginnanme> . Composer packages usually in vendor/<vendorname>/<packagename> . Also custom library should be placed within a unique subfolder to avoid conflicts with other script file paths. To do so, add following property into the project file library.msbuildproj : <PropertyGroup> <PhpRelativePath> vendor/example/library </PhpRelativePath> </PropertyGroup> More at project file's PhpRelativePath . After that, the script file class1.php can be included at <?php require_once './vendor/example/library/class1.php' ;","title":"Library subfolder"},{"location":"scenarios/beginner/reference-php-project/#see-also","text":"Creating a NuGet from a PHP project What is NuGet (docs.microsoft.com) Signing NuGet Packages (docs.microsoft.com) Project File Reference","title":"See also"},{"location":"scenarios/beginner/vs-console-app/","text":"Console App in Visual Studio # This tutorial describes how to create, run and debug a console application in Visual Studio. Assuming you have installed following: Visual Studio 2019 or newer PeachPie for Visual Studio Create a project # First you need a project . Create one right from Visual Studio - either from the Visual Studio 2019 start screen using Create a new project , or in the menu File | New | Project ( Ctrl+Shift+N ). Select the PHP language and search for \"PeachPie\" in the project templates. A list of various project templates will be populated. In the window select PeachPie Console App (.NET Core) template, and then continue with Next . If you do not see the project template, make sure you have installed the PeachPie for Visual Studio extension. In the next step, choose a project name and its location. Continue by pressing the Create button. Build and Debug # The application can be built in order to create a binary file, run and debugged. The binary file is an executable running under .NET Core Runtime . It allows to be executed on Linux, MacOS, Windows and other supported systems. Build the app # In the project menu, choose Build . In case of any issues, see the Output pane in Visual Studio, which provides a log with the build process, potential exceptions and other issues. Debug the app # Choose the green Start button or press F5 to build and debug the application. If your console application doesn't contain any errors, you'll see a console window with the \"Hello World!\" text: Hello World! ConsoleApp2.exe ( process 14116 ) exited with code 0 . Press any key to close this window . . . Set a startup object # You already have a simple hello world application, consisting of a single script file. However, the application will need to know where to run from once there will be more logic and more code. By default, using this project template, the application starts with the program.php script file. This is a build property of the application, and you can only have a single startup script specified. The startup object is a build property, so you can specify just a single startup object for the project. However, you can define more build configurations, each with different properties. Let's create a function main() and set it as the startup object instead of program.php . Add function main # Replace the code in program.php with the following: <?php /** The entry point of the program. */ function main () { echo \"Hello World!\" ; } If you were to start the application now, nothing would happen. Nothing is calling the new function and thus the program simply exits. Set new startup object # To control what runs after the application starts, we have to change the build property StartupObject . Edit the the projecty file by right clicking on the project in the Solution Explorer and choose Edit Project File . Find the line with <StartupObject> program.php </StartupObject> and change it to the following: <StartupObject> main </StartupObject> Here you can specify any PHP file relative to the project root, or a function. Run the program again # Try it again. Put a breakpoint ( F9 ) as depicted in the screenshot below: And start debugging the program ( F5 ). The application will recompile, and start while being debugged. Next steps # Add more code Create a self executable Integrate with C# or NuGet packages","title":"Console App in Visual Studio"},{"location":"scenarios/beginner/vs-console-app/#console-app-in-visual-studio","text":"This tutorial describes how to create, run and debug a console application in Visual Studio. Assuming you have installed following: Visual Studio 2019 or newer PeachPie for Visual Studio","title":"Console App in Visual Studio"},{"location":"scenarios/beginner/vs-console-app/#create-a-project","text":"First you need a project . Create one right from Visual Studio - either from the Visual Studio 2019 start screen using Create a new project , or in the menu File | New | Project ( Ctrl+Shift+N ). Select the PHP language and search for \"PeachPie\" in the project templates. A list of various project templates will be populated. In the window select PeachPie Console App (.NET Core) template, and then continue with Next . If you do not see the project template, make sure you have installed the PeachPie for Visual Studio extension. In the next step, choose a project name and its location. Continue by pressing the Create button.","title":"Create a project"},{"location":"scenarios/beginner/vs-console-app/#build-and-debug","text":"The application can be built in order to create a binary file, run and debugged. The binary file is an executable running under .NET Core Runtime . It allows to be executed on Linux, MacOS, Windows and other supported systems.","title":"Build and Debug"},{"location":"scenarios/beginner/vs-console-app/#build-the-app","text":"In the project menu, choose Build . In case of any issues, see the Output pane in Visual Studio, which provides a log with the build process, potential exceptions and other issues.","title":"Build the app"},{"location":"scenarios/beginner/vs-console-app/#debug-the-app","text":"Choose the green Start button or press F5 to build and debug the application. If your console application doesn't contain any errors, you'll see a console window with the \"Hello World!\" text: Hello World! ConsoleApp2.exe ( process 14116 ) exited with code 0 . Press any key to close this window . . .","title":"Debug the app"},{"location":"scenarios/beginner/vs-console-app/#set-a-startup-object","text":"You already have a simple hello world application, consisting of a single script file. However, the application will need to know where to run from once there will be more logic and more code. By default, using this project template, the application starts with the program.php script file. This is a build property of the application, and you can only have a single startup script specified. The startup object is a build property, so you can specify just a single startup object for the project. However, you can define more build configurations, each with different properties. Let's create a function main() and set it as the startup object instead of program.php .","title":"Set a startup object"},{"location":"scenarios/beginner/vs-console-app/#add-function-main","text":"Replace the code in program.php with the following: <?php /** The entry point of the program. */ function main () { echo \"Hello World!\" ; } If you were to start the application now, nothing would happen. Nothing is calling the new function and thus the program simply exits.","title":"Add function main"},{"location":"scenarios/beginner/vs-console-app/#set-new-startup-object","text":"To control what runs after the application starts, we have to change the build property StartupObject . Edit the the projecty file by right clicking on the project in the Solution Explorer and choose Edit Project File . Find the line with <StartupObject> program.php </StartupObject> and change it to the following: <StartupObject> main </StartupObject> Here you can specify any PHP file relative to the project root, or a function.","title":"Set new startup object"},{"location":"scenarios/beginner/vs-console-app/#run-the-program-again","text":"Try it again. Put a breakpoint ( F9 ) as depicted in the screenshot below: And start debugging the program ( F5 ). The application will recompile, and start while being debugged.","title":"Run the program again"},{"location":"scenarios/beginner/vs-console-app/#next-steps","text":"Add more code Create a self executable Integrate with C# or NuGet packages","title":"Next steps"},{"location":"scenarios/intermediate/debugging-peachpie/","text":"Debugging the compiler & runtime # The following article describes the development and debugging of the PeachPie platform itself. It contains the best practices when running PeachPie from the sources. It is intended for developers of PeachPie itself. There are two approaches to debugging the platform internals, depending on whether you target a small piece of code (A) or an entire application (B) . It is suggested to disable the Just My Code feature to debug through the runtime internals. See your debugger documentation on how to do that. Debug compilation & execution of a code snippet # Requirements : Visual Studio Project : /src/Tests/Peachpie.Test/Peachpie.Test.csproj Having just a small piece of code or a test case is the easiest way to debug the compiler and runtime. It is sufficient when debugging an isolated language construct, a test case, or a new library function. In Visual Studio open the Peachpie.sln solution, make the project Peachpie.Test your startup project . Navigate to index.php within the project and alter its content with your PHP test case. Optionally, you can put breakpoints inside the index.php file. It will break during the code snippet execution. Start the project - by default it runs an in-memory compilation of the script allowing you to debug the compiler code. Then it runs the compiled code itself allowing you to debug the runtime and libraries as well. Debug an entire application # Here, we assume you created a project ( .msbuildproj ) and you need to debug its compilation or runtime. This section is intended for developers debugging the PeachPie platform for a specific project . Prepare a development build of PeachPie # All the PeachPie libraries are distributed as Release builds. In some cases it is sufficient to debug those (e.g. to handle exceptions). In case you need to debug your own build of PeachPie (e.g. you're developing a feature or a fix in the PeachPie project sources), build the project from its sources. In the PeachPie project folder: # Build Peachpie.sln : dotnet build Copy the build output to your local NuGet cache: cd build . \\u pdate-dependencies.ps1 After these steps, there are PeachPie packages with a versioned 1.0.0-dev installed on your system. In your PHP project folder: # Wherever it occurs in your project, change the version of the PeachPie.*** references to 1.0.0-dev . Alter your project file targeting the development build of PeachPie: Example project file targeting development build of PeachPie: <Project Sdk= \"Peachpie.NET.Sdk/1.0.0-dev\" > <PropertyGroup> <OutputType> library </OutputType> <TargetFramework> netstandard2.0 </TargetFramework> </PropertyGroup> </Project> Restore your project: dotnet restore Debug the compilation of a project # In order to debug the compilation, you have to attach to the compilation process (msbuild running the Compile task). Use the MSBuild property DebuggerAttach to instruct the compiler to attach a debugger to itself. Run the build with the property DebuggerAttach set to true : dotnet build /p:DebuggerAttach = true This causes the compiler process to call System.Diagnostics.Debugger.Launch() upon the start, allowing you to choose a debugger (Visual Studio) and step into the compilation process. If asked, choose the debugger engine .NET Core or accordingly. Debug Runtime and Libraries # Start you project from within the IDE in debug mode. In Visual Studio , ensure you have disabled Just My Code . In VS Code , alter your launch configuration to search for debug symbols in your PeachPie build directories: .vscode/launch.json : \"justMyCode\" : false , \"symbolOptions\" : { \"searchPaths\" :[ \"C:\\\\peachpie\\\\src\\\\Peachpie.App\\\\bin\\\\Debug\\netstandard2.0\" ] } The Core CLR debugger will allow you to step into the PeachPie sources then.","title":"Debugging the compiler & runtime"},{"location":"scenarios/intermediate/debugging-peachpie/#debugging-the-compiler-runtime","text":"The following article describes the development and debugging of the PeachPie platform itself. It contains the best practices when running PeachPie from the sources. It is intended for developers of PeachPie itself. There are two approaches to debugging the platform internals, depending on whether you target a small piece of code (A) or an entire application (B) . It is suggested to disable the Just My Code feature to debug through the runtime internals. See your debugger documentation on how to do that.","title":"Debugging the compiler &amp; runtime"},{"location":"scenarios/intermediate/debugging-peachpie/#debug-compilation-execution-of-a-code-snippet","text":"Requirements : Visual Studio Project : /src/Tests/Peachpie.Test/Peachpie.Test.csproj Having just a small piece of code or a test case is the easiest way to debug the compiler and runtime. It is sufficient when debugging an isolated language construct, a test case, or a new library function. In Visual Studio open the Peachpie.sln solution, make the project Peachpie.Test your startup project . Navigate to index.php within the project and alter its content with your PHP test case. Optionally, you can put breakpoints inside the index.php file. It will break during the code snippet execution. Start the project - by default it runs an in-memory compilation of the script allowing you to debug the compiler code. Then it runs the compiled code itself allowing you to debug the runtime and libraries as well.","title":"Debug compilation &amp; execution of a code snippet"},{"location":"scenarios/intermediate/debugging-peachpie/#debug-an-entire-application","text":"Here, we assume you created a project ( .msbuildproj ) and you need to debug its compilation or runtime. This section is intended for developers debugging the PeachPie platform for a specific project .","title":"Debug an entire application"},{"location":"scenarios/intermediate/debugging-peachpie/#prepare-a-development-build-of-peachpie","text":"All the PeachPie libraries are distributed as Release builds. In some cases it is sufficient to debug those (e.g. to handle exceptions). In case you need to debug your own build of PeachPie (e.g. you're developing a feature or a fix in the PeachPie project sources), build the project from its sources.","title":"Prepare a development build of PeachPie"},{"location":"scenarios/intermediate/debugging-peachpie/#in-the-peachpie-project-folder","text":"Build Peachpie.sln : dotnet build Copy the build output to your local NuGet cache: cd build . \\u pdate-dependencies.ps1 After these steps, there are PeachPie packages with a versioned 1.0.0-dev installed on your system.","title":"In the PeachPie project folder:"},{"location":"scenarios/intermediate/debugging-peachpie/#in-your-php-project-folder","text":"Wherever it occurs in your project, change the version of the PeachPie.*** references to 1.0.0-dev . Alter your project file targeting the development build of PeachPie: Example project file targeting development build of PeachPie: <Project Sdk= \"Peachpie.NET.Sdk/1.0.0-dev\" > <PropertyGroup> <OutputType> library </OutputType> <TargetFramework> netstandard2.0 </TargetFramework> </PropertyGroup> </Project> Restore your project: dotnet restore","title":"In your PHP project folder:"},{"location":"scenarios/intermediate/debugging-peachpie/#debug-the-compilation-of-a-project","text":"In order to debug the compilation, you have to attach to the compilation process (msbuild running the Compile task). Use the MSBuild property DebuggerAttach to instruct the compiler to attach a debugger to itself. Run the build with the property DebuggerAttach set to true : dotnet build /p:DebuggerAttach = true This causes the compiler process to call System.Diagnostics.Debugger.Launch() upon the start, allowing you to choose a debugger (Visual Studio) and step into the compilation process. If asked, choose the debugger engine .NET Core or accordingly.","title":"Debug the compilation of a project"},{"location":"scenarios/intermediate/debugging-peachpie/#debug-runtime-and-libraries","text":"Start you project from within the IDE in debug mode. In Visual Studio , ensure you have disabled Just My Code . In VS Code , alter your launch configuration to search for debug symbols in your PeachPie build directories: .vscode/launch.json : \"justMyCode\" : false , \"symbolOptions\" : { \"searchPaths\" :[ \"C:\\\\peachpie\\\\src\\\\Peachpie.App\\\\bin\\\\Debug\\netstandard2.0\" ] } The Core CLR debugger will allow you to step into the PeachPie sources then.","title":"Debug Runtime and Libraries"},{"location":"scenarios/intermediate/decompilation/","text":"Decompilation overview # For the purposes of development and optimization, it is useful to check the compiled DLL file. It serves for several purposes; First , the developer sees the classes and interfaces exposed from the compiled assembly. Second , decompilation reveals how the compiler treats some PHP constructs and declarations, so it can be used from C# or other .NET languages. It also allows for detecting errors in or improving the compiler. Third , performance critical pieces of code should be reviewed and, if possible, type information or a better decomposition should be added to the source code to improve the type analysis and thus the compilation result. See performance for more information. Try PeachPie # The community project try.peachpie.io allows for an immediate look into the .NET byte code generated from PHP code. This is useful for the decompilation of small PHP snippets. The site internally (and in-memory) compiles the given PHP code and shows the byte code live, with an option to decompile to C# code. ILSpy # A handy tool for decompiling entire assemblies. In case there is a large PHP project or a project consisting of more script files in general, ILSpy provides all the functionality needed for both checking the assembly and performance fine-tuning. The tool gets error messages in case the compiled assembly is not valid (e.g. the compiler missbehavior) and gets nice view of the compiled assembly structure . disasm # disasm is a basic tool getting all the metadata and IL stream of a compiled DLL file. Recommended for hardcore IL hunters.","title":"Decompilation overview"},{"location":"scenarios/intermediate/decompilation/#decompilation-overview","text":"For the purposes of development and optimization, it is useful to check the compiled DLL file. It serves for several purposes; First , the developer sees the classes and interfaces exposed from the compiled assembly. Second , decompilation reveals how the compiler treats some PHP constructs and declarations, so it can be used from C# or other .NET languages. It also allows for detecting errors in or improving the compiler. Third , performance critical pieces of code should be reviewed and, if possible, type information or a better decomposition should be added to the source code to improve the type analysis and thus the compilation result. See performance for more information.","title":"Decompilation overview"},{"location":"scenarios/intermediate/decompilation/#try-peachpie","text":"The community project try.peachpie.io allows for an immediate look into the .NET byte code generated from PHP code. This is useful for the decompilation of small PHP snippets. The site internally (and in-memory) compiles the given PHP code and shows the byte code live, with an option to decompile to C# code.","title":"Try PeachPie"},{"location":"scenarios/intermediate/decompilation/#ilspy","text":"A handy tool for decompiling entire assemblies. In case there is a large PHP project or a project consisting of more script files in general, ILSpy provides all the functionality needed for both checking the assembly and performance fine-tuning. The tool gets error messages in case the compiled assembly is not valid (e.g. the compiler missbehavior) and gets nice view of the compiled assembly structure .","title":"ILSpy"},{"location":"scenarios/intermediate/decompilation/#disasm","text":"disasm is a basic tool getting all the metadata and IL stream of a compiled DLL file. Recommended for hardcore IL hunters.","title":"disasm"},{"location":"scenarios/intermediate/interop-in-csharp/","text":"C# code using PHP Referencing PHP project by C# project PHP code lifecycle (Load, Context) calling PHP functions and passing arguments set PHP global variable/constant instantiate PHP class extend PHP class or interface delegates objects Related links You can also refer to all our articles in our blog on the topic of interoperability for more information.","title":"Interop in csharp"},{"location":"scenarios/intermediate/interop-in-php/","text":"PHP code using .NET referencing .NET library implicit conversion from PhpValue using all the .NET objects in PHP code passing values to .NET methods extending .NET class or interface in PHP Related links You can also refer to all our articles in our blog on the topic of interoperability for more information.","title":"Interop in php"},{"location":"scenarios/intermediate/nightly-builds/","text":"PeachPie Nightly Builds # The latest build of PeachPie is always available on our AppVeyor feed. The build is annotated as a PreRelease version. Register Package Source # Add the following NuGet feed source: https://ci.appveyor.com/nuget/peachpie Either on command line: dotnet nuget add source https://ci.appveyor.com/nuget/peachpie -n peachpie-appveyor Or create the NuGet.config file in the root of your project: <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <add key= \"peachpie-appveyor\" value= \"https://ci.appveyor.com/nuget/peachpie\" /> </packageSources> </configuration> Use the Nightly Build # Then the latest build has to be used by PHP projects. Edit the .msbuildproj project file and update the PeachPie packages version to the latest AppVeyor version. The version number can be found on https://ci.appveyor.com/project/dotnetfoundation/peachpie/history . <Project Sdk= \"Peachpie.NET.Sdk/1.0.0-appv4625\" > <PropertyGroup> <OutputType> library </OutputType> <TargetFramework> netstandard2.1 </TargetFramework> </PropertyGroup> <ItemGroup> <Compile Include= \"**/*.php\" /> </ItemGroup> </Project> In this sample, we are using version 1.0.0-appv4625 . Note, if you reference any other Peachpie packages in other projects, it is recommended to use the same version across the entire solution.","title":"PeachPie Nightly Builds"},{"location":"scenarios/intermediate/nightly-builds/#peachpie-nightly-builds","text":"The latest build of PeachPie is always available on our AppVeyor feed. The build is annotated as a PreRelease version.","title":"PeachPie Nightly Builds"},{"location":"scenarios/intermediate/nightly-builds/#register-package-source","text":"Add the following NuGet feed source: https://ci.appveyor.com/nuget/peachpie Either on command line: dotnet nuget add source https://ci.appveyor.com/nuget/peachpie -n peachpie-appveyor Or create the NuGet.config file in the root of your project: <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <add key= \"peachpie-appveyor\" value= \"https://ci.appveyor.com/nuget/peachpie\" /> </packageSources> </configuration>","title":"Register Package Source"},{"location":"scenarios/intermediate/nightly-builds/#use-the-nightly-build","text":"Then the latest build has to be used by PHP projects. Edit the .msbuildproj project file and update the PeachPie packages version to the latest AppVeyor version. The version number can be found on https://ci.appveyor.com/project/dotnetfoundation/peachpie/history . <Project Sdk= \"Peachpie.NET.Sdk/1.0.0-appv4625\" > <PropertyGroup> <OutputType> library </OutputType> <TargetFramework> netstandard2.1 </TargetFramework> </PropertyGroup> <ItemGroup> <Compile Include= \"**/*.php\" /> </ItemGroup> </Project> In this sample, we are using version 1.0.0-appv4625 . Note, if you reference any other Peachpie packages in other projects, it is recommended to use the same version across the entire solution.","title":"Use the Nightly Build"},{"location":"scenarios/intermediate/razor/","text":"This tutorial explains how to work with Razor partials together with PHP, in both directions. To understand this process better, please refer to this sample . Rendering Razor partial views in PHP # In order to handle requests to .php files compiled into a project (e.g. php-library in this case) in your C# MVC app, you must first configure the ASP.NET Core pipeline in Startup.cs as follows: app . UsePhp ( new PhpRequestOptions ( scriptAssemblyName : \"php-library\" )); Now start the project and a request to \u2018index.php\u2019 will be served. The sample C# MVC app already contains a shared partial view called \u201c_User.cshtml\u201d. In our sample, you can see the php-library project, where a Razor partial view is being rendered within the index.php file: <?php use Peachpie\\AspNetCore\\Mvc\\HttpContextExtension as Html ; class User { var $Name = \"John\" ; var $Address = \"Partial Street 123\" ; } ?> <? = Html :: Partial ( \"_User\" , new User ) ?> Peachpie\\AspNetCore\\Mvc\\HttpContextExtension::Partial(string $viewName, object $model) is a helper function that finds the partial view \u201c_User\u201d, renders it and retrieves its output. It is then \u201cechoed\u201d using PHP\u2019s <?= syntax. Add a reference to your php-library project file, which implements the helper function above: <PackageReference Include= \"Peachpie.AspNetCore.Mvc\" Version= \"1.0.6\" /> Rendering a PHP script in Razor # Start by compiling your PHP project into a DLL file. Note OutputType must be library and TargetFramework is netstandard2.0, because we are building a library that will be referenced by your C# MVC app. Next, add a reference to the MVC project: <PackageReference Include= \"Peachpie.AspNetCore.Mvc\" Version= \"1.0.6\" /> <ProjectReference Include= \"../myPhpApp/myPhpApp.msbuildproj\" /> And finally, provide the PHP scripts to the runtime. This must be done once when the application is running, and can be achieved by inserting the code into the Startup object, specifically into the ConfigureServices method in the ASP.NET Core configuration: Context . AddScriptReference ( Assembly . Load ( \"myPhpApp\" ) ); Now you can display the output of your PHP script inside a Razor or Partial View (.cshtml), e.g.: @using Peachpie.AspNetCore.Mvc; < h1 > Razor View </ h1 > @Html.Php(\"test.php\") MVC Model objects # If you want to pass data to your PHP script, you can do so by specifying the second parameter of the Php(\"test.php\", model) method. You can pass the current .NET Model or any other object. To use it, simply refer to $this variable in the PHP code. If you are not comfortable with using $this , you can take advantage of the PeachPie API and pass any C# variable into a global PHP variable by calling something like: HttpContext . GetOrCreateContext (). Globals [ \"mydata\" ] = \"Hi from C#!\" ; This code will create a PHP global variable $mydata . GetOrCreateContext() is an extension method that gets you the PHP Context out of the ASP.NET Core HttpContext. Additional resources # Sample code Razor pages docs Article on rendering PHP in Razor Article on rendering Razor in PHP","title":"Razor"},{"location":"scenarios/intermediate/razor/#rendering-razor-partial-views-in-php","text":"In order to handle requests to .php files compiled into a project (e.g. php-library in this case) in your C# MVC app, you must first configure the ASP.NET Core pipeline in Startup.cs as follows: app . UsePhp ( new PhpRequestOptions ( scriptAssemblyName : \"php-library\" )); Now start the project and a request to \u2018index.php\u2019 will be served. The sample C# MVC app already contains a shared partial view called \u201c_User.cshtml\u201d. In our sample, you can see the php-library project, where a Razor partial view is being rendered within the index.php file: <?php use Peachpie\\AspNetCore\\Mvc\\HttpContextExtension as Html ; class User { var $Name = \"John\" ; var $Address = \"Partial Street 123\" ; } ?> <? = Html :: Partial ( \"_User\" , new User ) ?> Peachpie\\AspNetCore\\Mvc\\HttpContextExtension::Partial(string $viewName, object $model) is a helper function that finds the partial view \u201c_User\u201d, renders it and retrieves its output. It is then \u201cechoed\u201d using PHP\u2019s <?= syntax. Add a reference to your php-library project file, which implements the helper function above: <PackageReference Include= \"Peachpie.AspNetCore.Mvc\" Version= \"1.0.6\" />","title":"Rendering Razor partial views in PHP"},{"location":"scenarios/intermediate/razor/#rendering-a-php-script-in-razor","text":"Start by compiling your PHP project into a DLL file. Note OutputType must be library and TargetFramework is netstandard2.0, because we are building a library that will be referenced by your C# MVC app. Next, add a reference to the MVC project: <PackageReference Include= \"Peachpie.AspNetCore.Mvc\" Version= \"1.0.6\" /> <ProjectReference Include= \"../myPhpApp/myPhpApp.msbuildproj\" /> And finally, provide the PHP scripts to the runtime. This must be done once when the application is running, and can be achieved by inserting the code into the Startup object, specifically into the ConfigureServices method in the ASP.NET Core configuration: Context . AddScriptReference ( Assembly . Load ( \"myPhpApp\" ) ); Now you can display the output of your PHP script inside a Razor or Partial View (.cshtml), e.g.: @using Peachpie.AspNetCore.Mvc; < h1 > Razor View </ h1 > @Html.Php(\"test.php\")","title":"Rendering a PHP script in Razor"},{"location":"scenarios/intermediate/razor/#mvc-model-objects","text":"If you want to pass data to your PHP script, you can do so by specifying the second parameter of the Php(\"test.php\", model) method. You can pass the current .NET Model or any other object. To use it, simply refer to $this variable in the PHP code. If you are not comfortable with using $this , you can take advantage of the PeachPie API and pass any C# variable into a global PHP variable by calling something like: HttpContext . GetOrCreateContext (). Globals [ \"mydata\" ] = \"Hi from C#!\" ; This code will create a PHP global variable $mydata . GetOrCreateContext() is an extension method that gets you the PHP Context out of the ASP.NET Core HttpContext.","title":"MVC Model objects"},{"location":"scenarios/intermediate/razor/#additional-resources","text":"Sample code Razor pages docs Article on rendering PHP in Razor Article on rendering Razor in PHP","title":"Additional resources"},{"location":"scenarios/intermediate/self-contained-exe/","text":"Self-contained executable # To create a self-contained PHP executable, start with a console application, e.g.: <?php echo \"Hello world!\" ; and a corresponding project file indicating that the output should be exe: <Project Sdk= \"Peachpie.NET.Sdk/1.0.6\" > <PropertyGroup> <OutputType> exe </OutputType> <TargetFramework> netcoreapp3.1 </TargetFramework> <StartupObject> main.php </StartupObject> </PropertyGroup> <ItemGroup> <Compile Include= \"**/*.php\" /> </ItemGroup> </Project> Now compile your project into binaries using the following command: dotnet publish -c release This will publish the resulting binaries into the /bin/release/netcoreapp3.1/publish folder. As the final step, select an operating system to target, e.g. dotnet publish -c release -r win-x64 for 64-bit Windows, or dotnet publish -c release -r linux-x64 for Linux. This creates a self-contained executable PHP application targeting the operating system of your choice. Size considerations # A few tips on how to minimize the size of the resulting application: On Linux, you can get rid of culture-specific functionalities and keep just the \"Invariant\" culture features (cuts about 26MB of data). More detail at globalization-invariant-mode.md . Use dotnet-warp to merge DLL files and remove unnecessary IL and methods. More info can be found at hanselman.com . Note Rename the project file so that it has the .csproj extension, it will work just fine. Resources # Blog post on self-contained executable PHP apps Runtime Identifier (RID) catalog dotnet-warp PeachPie getting started dotnet publish PeachPie samples ASP.NET Core Web Server","title":"Self-contained executable"},{"location":"scenarios/intermediate/self-contained-exe/#self-contained-executable","text":"To create a self-contained PHP executable, start with a console application, e.g.: <?php echo \"Hello world!\" ; and a corresponding project file indicating that the output should be exe: <Project Sdk= \"Peachpie.NET.Sdk/1.0.6\" > <PropertyGroup> <OutputType> exe </OutputType> <TargetFramework> netcoreapp3.1 </TargetFramework> <StartupObject> main.php </StartupObject> </PropertyGroup> <ItemGroup> <Compile Include= \"**/*.php\" /> </ItemGroup> </Project> Now compile your project into binaries using the following command: dotnet publish -c release This will publish the resulting binaries into the /bin/release/netcoreapp3.1/publish folder. As the final step, select an operating system to target, e.g. dotnet publish -c release -r win-x64 for 64-bit Windows, or dotnet publish -c release -r linux-x64 for Linux. This creates a self-contained executable PHP application targeting the operating system of your choice.","title":"Self-contained executable"},{"location":"scenarios/intermediate/self-contained-exe/#size-considerations","text":"A few tips on how to minimize the size of the resulting application: On Linux, you can get rid of culture-specific functionalities and keep just the \"Invariant\" culture features (cuts about 26MB of data). More detail at globalization-invariant-mode.md . Use dotnet-warp to merge DLL files and remove unnecessary IL and methods. More info can be found at hanselman.com . Note Rename the project file so that it has the .csproj extension, it will work just fine.","title":"Size considerations"},{"location":"scenarios/intermediate/self-contained-exe/#resources","text":"Blog post on self-contained executable PHP apps Runtime Identifier (RID) catalog dotnet-warp PeachPie getting started dotnet publish PeachPie samples ASP.NET Core Web Server","title":"Resources"}]}